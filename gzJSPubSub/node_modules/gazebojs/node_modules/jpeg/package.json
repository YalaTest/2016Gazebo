{
  "name": "jpeg",
  "version": "2.0.0",
  "main": "build/Release/jpeg",
  "description": "A C++ module for node-js that converts RGB and RGBA buffers to a JPEG images (in memory).",
  "keywords": [
    "jpg",
    "rgba",
    "rgb",
    "image",
    "picture"
  ],
  "author": {
    "name": "Peteris Krumins",
    "email": "peteris.krumins@gmail.com",
    "url": "http://www.catonmat.net"
  },
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "http://github.com/pkrumins/node-jpeg.git"
  },
  "directories": {
    "examples": "examples",
    "src": "src"
  },
  "engines": {
    "node": ">=0.1.93"
  },
  "scripts": {
    "install": "node-gyp configure build"
  },
  "readme": "This is a node.js module, writen in C++, that uses libjpeg to produce a JPEG\r\nimage (in memory) from a buffer of RGBA or RGB values. Since JPEG has no notion\r\nof A (alpha), the module always uses just RGB values.\r\n\r\nIt was written by Peteris Krumins (peter@catonmat.net).\r\nHis blog is at http://www.catonmat.net  --  good coders code, great reuse.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe module exports three objects: Jpeg, FixedJpegStack, DynamicJpegStack.\r\n\r\nJpeg allows to create fixed size jpegs from RGB, BGR, RGBA or BGRA buffers.\r\nFixedJpegStack allows to push multiple jpegs to a fixed size canvas.\r\nDynamicJpegStack allows to push multiple jpegs to a dynamic size canvas (it\r\ngrows as you push jpegs to it).\r\n\r\nAll objects provide synchronous and asynchronous interfaces.\r\n\r\n##Jpeg\r\n\r\nJpeg object that takes 4 arguments in its constructor:\r\n\r\n```javascript\r\n    var jpeg = new Jpeg(buffer, width, height, [buffer_type]);\r\n```\r\n\r\nThe first argument, `buffer`, is a nodee.js `Buffer` filled with RGBA or RGB\r\nvalues.\r\nThe second argument is integer width of the image.\r\nThe third argument is integer height of the image.\r\nThe fourth argument is buffer type, either 'rgb' or 'rgba'. [Optional].\r\n\r\nAfter you have constructed the object, call .encode() or .encodeSync to produce\r\na jpeg:\r\n```javascript\r\n    var jpeg_image = jpeg.encodeSync(); // synchronous encoding (blocks node.js)\r\n```\r\nOr:\r\n```javascript\r\n    jpeg.encode(function (image, error) {\r\n        // jpeg image is in 'image'\r\n    });\r\n```\r\nSee `examples/` directory for examples.\r\n\r\n\r\n##FixedJpegStack\r\n\r\nFirst you create a FixedJpegStack object of fixed width and height:\r\n```javascript\r\n    var stack = new FixedJpegStack(width, height, [buffer_type]);\r\n```\r\nThen you can push individual fragments to it, for example,\r\n```javascript\r\n    stack.push(buf1, 10, 11, 100, 200); // pushes buf1 to (x,y)=(10,11)\r\n                                        // 100 and 200 are width and height.\r\n\r\n    // more pushes\r\n```\r\nAfter you're done, call `.encode()` to produce final jpeg asynchronously or\r\n`.encodeSync()` (just like in Jpeg object). The final jpeg will be of size\r\nwidth x height.\r\n\r\n\r\n##DynamicJpegStack\r\n\r\nDynamicJpegStack is the same as FixedJpegStack except its canvas grows dynamically.\r\n\r\nFirst, create the stack:\r\n```javascript\r\n    var stack = new DynamicJpegStack([buffer_type]);\r\n```\r\nNext push the RGB(A) buffers to it:\r\n```javascript\r\n    stack.push(buf1, 5, 10, 100, 40);\r\n    stack.push(buf2, 2, 210, 20, 20);\r\n```\r\nNow you can call `encode` to produce the final jpeg:\r\n```javascript\r\n    var jpeg = stack.encodeSync();\r\n```\r\nNow let's see what the dimensions are,\r\n```javascript\r\n    var dims = stack.dimensions();\r\n```\r\nSame asynchronously:\r\n```javascript\r\n    stack.encode(function (jpeg, dims) {\r\n        // jpeg is the image\r\n        // dims are its dimensions\r\n    });\r\n```\r\nIn this particular example:\r\n\r\nThe x position `dims.x` is 2 because the 2nd jpeg is closer to the left.\r\nThe y position `dims.y` is 10 because the 1st jpeg is closer to the top.\r\nThe width `dims.width` is 103 because the first jpeg stretches from x=5 to\r\nx=105, but the 2nd jpeg starts only at x=2, so the first two pixels are not\r\nnecessary and the width is 105-2=103.\r\nThe height `dims.height` is 220 because the 2nd jpeg is located at 210 and\r\nits height is 20, so it stretches to position 230, but the first jpeg starts\r\nat 10, so the upper 10 pixels are not necessary and height becomes 230-10= 220.\r\n\r\n\r\n##How to install?\r\n\r\n\r\nTo get it compiled, you need to have libjpeg and node installed. Then just run\r\n```bash\r\n    node-waf configure build\r\n```\r\nto build the Jpeg module. It will produce a `jpeg.node` file as the module.\r\n\r\nSee also http://github.com/pkrumins/node-png module that produces PNG images.\r\nSee also http://github.com/pkrumins/node-gif module that produces GIF images.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nHave fun!\r\n\r\n\r\nSincerely,\r\nPeteris Krumins\r\nhttp://www.catonmat.net\r\n\r\n",
  "readmeFilename": "readme.md",
  "bugs": {
    "url": "https://github.com/pkrumins/node-jpeg/issues"
  },
  "_id": "jpeg@2.0.0",
  "_from": "jpeg@^2.0.0"
}
